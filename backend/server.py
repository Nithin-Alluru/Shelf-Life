from flask import Flask, request, jsonify
from flask_cors import CORS
from book_api import fetch_books_from_api, parse_books, get_book
import sqlite3
from flask_jwt_extended import JWTManager
from flask_jwt_extended import jwt_required, get_jwt_identity
from auth import auth, bcrypt
import os


DATABASE = "./social-books.db" # This is the .db file generated by Yoon and Connor

app = Flask(__name__)
CORS(app)  # Allow frontend to communicate with backend

bcrypt.init_app(app)  # Initialize bcrypt for password hashing

# Initialize JWT here
app.config["JWT_SECRET_KEY"] = os.getenv("JWT_SECRET_KEY", "fallback-secret-key")  # Use env variable
jwt = JWTManager(app)

# Register the authentication blueprint
app.register_blueprint(auth, url_prefix="/auth")

bcrypt.init_app(app)  # Initialize bcrypt for password hashing

@app.route("/", methods=["GET"])
def home():
	return jsonify({"message": "Flask API is running"}), 200


@app.route('/parse', methods=['POST'])
def parse_book():
    try:
        data = request.json  # Receive JSON from frontend
        book_ISBN = list(data.keys())[0]
        book_title = data[book_ISBN]["title"]
        book_author = data[book_ISBN]["author"]
        
        return jsonify({
            "ISBN": book_ISBN,
            "title": book_title,
            "author": book_author
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route('/book/<string:work_id>', methods=['GET'])
def book(work_id):
    """
    Flask route to handle book get requests.
    
    Returns:
        Response: JSON response containing book details or an error message.
    """
    # Use the get_book function to get the search results
    book = get_book(work_id=work_id)
    return book

# Author Nithin -- reference for clarification.
@app.route('/search', methods=['GET'])
def search_books():
    """
    Flask route to handle book search requests.
    
    Returns:
        Response: JSON response containing search results or an error message.
    """
    query = request.args.get('q')
    title = request.args.get('title')
    author = request.args.get('author')
    subject = request.args.get('subject')
    limit = request.args.get('limit')

    if not (query or title or author or subject):
        return jsonify({'error': 'Missing search parameter'}), 400

    # Use the fetch_books_from_api function to get the search results
    books = fetch_books_from_api(query=query, title=title, author=author, subject=subject, limit=limit)
    return jsonify(books)

# @app.route('/api/data') <-- re-enable this line if things break, shouldn't need it
def db_connect():
    """ Opens a connection to the database. Hosted at 127.0.0.1 IP (localhost) """
    try:
        # Connect to the sqlite database. Modify the path at the top.
        conn = sqlite3.connect(DATABASE)
        print(f"Connection to database {DATABASE} successful.")
    except sqlite3.Error as error:
        print(f"ERROR CONNECTING {DATABASE}: errcode {error}")
    
    conn.row_factory = sqlite3.Row

    return conn

# gets all user data for the reader profile page (only currently returning the username)
@app.route("/users/reader-profile", methods=["GET"])
@jwt_required()
def return_user_data():
    """ Returns all user info as a json object. 
    Not sure of the format here, might need more work. """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")

    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    query = """
        SELECT * FROM users
        WHERE users.username = ?
    """
    # executes this query, fetches one user's data
    user_data = conn.execute(query, (current_user,)).fetchone()
    conn.close()

    # Return the user info as a json dictionary, should return whole tuple info
    if user_data:
        return jsonify(dict(user_data))
    else:
        return jsonify({"error": f"user data not found"}), 404 #NOT FOUND
        
 
# need to integrate to use those in auth.py, remove <string:username> from url
# NOTE: does this need to insert other information also?
# ?
# ?
# ?
# ?
@app.route("/users/add/<string:username>", methods=["POST"])
def add_user(username):
    """ Adds a user to the database """

    if not username:
        return jsonify({"error": "no username given"}), 400 #BAD REQUEST
    
    conn = db_connect()
    cursor = conn.cursor()

    # Tries to insert, if a user_id already exists sqlite3 should throw an integrity error
    # Later on we want to change this from an error to some sort of front-end behavior
    # That's for further on this week
    try:
        query = "INSERT INTO users (username) VALUES (?)"
        cursor.execute(query, (username,))
        conn.commit()
    except sqlite3.IntegrityError:
        conn.close()
        return jsonify({"error": f"user {username} already exists"}), 409 #CONFLICT
    
    conn.close()

    return jsonify({"message": f"user {username} added successfully"}), 201 #CREATED

#remove <string:username> from url
@app.route("/users/delete-user/<string:username>", methods=["DELETE"])
def delete_user(username):
    """ Removes a user from the database """
    conn = db_connect()
    cursor = conn.cursor()


    if not username:
        return jsonify({"error": "no username given for deletion"}), 400 #BAD_REQUEST
    
    query = "SELECT username FROM users WHERE username = ?"
    cursor.execute(query, (username,))
    user = cursor.fetchone()

    if not user:
        conn.close()
        return jsonify({"error": "user not found for deletion from user table"}), 404 #NOT FOUND

    deletion_query = "DELETE FROM users WHERE username = ?"
    cursor.execute(deletion_query, (username,))
    conn.commit()
    conn.close()

    return jsonify({"message": f"user {username} deleted successfully from users table"}), 200 #OK



# NOTE: deleted the duplicate delete user method which was left over from the "reader_profiles" version



@app.route("/reviews", methods=["POST"])
@jwt_required()
def add_review():
    """ Adds a review. Content of the review needs to be in the POST query.
     So far this only updates the reviews table. Maybe update other tables? Probably not. """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")
        
    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?" # replaced profile_id with uesrname
    reviewer = cursor.execute(find_user_query, (current_user,)).fetchone()

    if not reviewer:
        conn.close()
        return jsonify({"error":f"user {current_user} not found, not updating reviews"}), 400 #BAD REQUEST
    
    r_metadata = request.json
    work_ID = r_metadata.get("work_id")
    rating = r_metadata.get("star_rating")
    liked = r_metadata.get("liked")
    text = r_metadata.get("review_text")
    
    from profanity_filter import is_profane
        
    profanity_list = is_profane(text)
    
    if profanity_list:
        conn.close()
        return jsonify({"error": f"Profanity detected in review: {profanity_list}"}), 412
    

    if not work_ID or not rating or not text:
        conn.close()
        return jsonify({"error": "work_ID, rating, or text is bad"}), 400 #BAD REQUEST
    
    if not (1 <= rating <= 5):
        conn.close()
        return jsonify({"error": "rating is out of 1-5 range"}), 412 #PRECONDITION FAILED
    
    try:
        query = "INSERT INTO reviews (username, work_ID, star_rating, liked, review_text) VALUES (?, ?, ?, ?, ?)"
        cursor.execute(query, (current_user, work_ID, rating, liked, text))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    return jsonify({"message": "Review added successfully", "user_id" : current_user, "work_ID" : work_ID}), 201 #CREATED


@app.route("/reviews/<string:review_id>", methods=["PUT"])
@jwt_required()
def update_review(review_id):
    """ Edits a review. Content of the review needs to be in the PUT query.
     So far this only updates the reviews table. Maybe update other tables? Probably not. """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")

    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?"
    reviewer = cursor.execute(find_user_query, (current_user,))

    if not reviewer:
        conn.close()
        return jsonify({"error":f"user {current_user} not found, not updating reviews"}), 400 #BAD REQUEST 
    
    r_metadata = request.json
    work_ID = r_metadata.get("work_id")
    rating = r_metadata.get("star_rating")
    liked = r_metadata.get("liked")
    text = r_metadata.get("review_text")
    
    from profanity_filter import is_profane
        
    profanity_list = is_profane(text)
    
    if profanity_list:
        conn.close()
        return jsonify({"error": f"Profanity detected in review: {profanity_list}"}), 412

    if not work_ID or not rating or not text:
        conn.close()
        return jsonify({"error": "work_ID, rating, or text is bad"}), 400 #BAD REQUEST
    
    if not (1 <= rating <= 5):
        conn.close()
        return jsonify({"error": "rating is out of 1-5 range"}), 412 #PRECONDITION FAILED
    
    try:
        query = f"UPDATE reviews (username, work_ID, star_rating, liked, review_text) SET (?, ?, ?, ?, ?) WHERE review_id = {review_id}"
        cursor.execute(query, (current_user, work_ID, rating, liked, text))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    return jsonify({"message": "Review edited successfully", "user_id" : current_user, "review_id" : review_id, "work_ID" : work_ID}), 201 #CREATE

# Delete a review
@app.route("/reviews/<string:review_id>", methods=["DELETE"])
def remove_review(review_id):
    """ This removes a review with a specific ID. """
    conn = db_connect()
    cursor = conn.cursor()

    find_review_query = "SELECT review_id FROM reviews WHERE review_id = ?"
    cursor.execute(find_review_query, (review_id,))
    review = cursor.fetchone()

    if not review:
        conn.close()
        return jsonify({"error":f"review {review_id} not found, not updating reviews"}), 400 #BAD REQUEST
    
    deletion_query = "DELETE FROM reviews WHERE review_id = ?"
    cursor.execute(deletion_query, (review_id,))
    conn.commit()
    conn.close()

    return jsonify({"message": f"review {review_id} deleted successfully"}), 200 #OK


# GET all reviews associated with a book
@app.route("/books/<string:work_ID>/reviews", methods=["GET"])
def return_review_data(work_ID):
    # check for valid work ID
    if work_ID == '' or work_ID == "undefined":
        return jsonify({"error": f"book {work_ID} not found or invalid"}), 404 #NOT FOUND

    """ Returns the book's reviews and review score average as a JSON object. """
    conn = db_connect()
    query = """
        SELECT * FROM reviews
        WHERE reviews.work_id = ?
    """

    # NOTE: Learned how to do the following 4 lines with ChatGPT prompt: "teach me how to create 
    # a list of dictionaries, with each list corresponding to a sqlite row, and each 
    # dictionary corresponding to a sqlite column name and its value in that row"
    cursor = conn.execute(query, (work_ID,))
    rows = cursor.fetchall()
    columns = [description[0] for description in cursor.description]
    reviews = [dict(zip(columns, row)) for row in rows]

    # default return value for no reviews
    if len(reviews) == 0:
        avg = -1
    else:
        # Get average review score
        query2 = """
        SELECT ROUND(AVG(star_rating), 1) FROM reviews
        WHERE reviews.work_id = ?
        """
        cursor = conn.execute(query2, (work_ID,))
        singleRow = cursor.fetchone()
        avg = (singleRow[0])


    reviews_data = {
            'work_id': work_ID, 
            'avg_rating': avg, 
            'reviews_list': reviews
    }
    conn.close()

    return jsonify(reviews_data)


# GET all reviews associated with a user
@app.route("/user/reviews", methods=["GET"])
@jwt_required()
def get_user_reviews():
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")
    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    query = """
        SELECT * FROM reviews
        WHERE reviews.username = ?
    """
    # NOTE: Learned how to do the following 4 lines with ChatGPT prompt: "teach me how to create 
    # a list of dictionaries, with each list corresponding to a sqlite row, and each 
    # dictionary corresponding to a sqlite column name and its value in that row"
    cursor = conn.execute(query, (current_user,))
    rows = cursor.fetchall()
    columns = [description[0] for description in cursor.description]
    reviews = [dict(zip(columns, row)) for row in rows]
    conn.close()

    # Return the book review info as a json dictionary, should return whole tuple info
    if reviews:
        return jsonify(reviews)
    else:
        return jsonify([])
 

#needs to be changed to '/followers' and edited to match other api's using required JWT data
@app.route("/followers/<string:user_id>/", methods=["POST"])
def add_follower(follows):
    """ Adds a follower. input to this fuction is the person to follow.
    Follower is specified in the JSON
    """
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?"
    reviewer = cursor.execute(find_user_query, (follows,))

    if not follows:
        conn.close()
        return jsonify({"error":f"user {follows} not found, not updating followers"}), 400 #BAD REQUEST
    
    r_metadata = request.json
    follower_username = r_metadata.get("follower_username")

    if not follower_username:
        conn.close()
        return jsonify({"error": "bad follower"}), 400 #BAD REQUEST
        
    try:
        query = "INSERT INTO followers (follower_username, follows_username) VALUES (?, ?)"
        cursor.execute(query, (follower_username, follows))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    reviewSerial += 1
    return jsonify({"message": "Follower added successfully", "follower" : follower_username, "follows" : follows}), 201 #CREATED


#needs to be changed to '/followers' and edited to match other api's using required JWT data
@app.route("/followers", methods=["GET"])
def get_followers(username):
    """ Return a user's followers. Returns empty list no followers """
    conn = db_connect()
    
    usercheck = """
        SELECT COUNT(username)
        FROM users
        WHERE username = ?
    """

    # check if user exists
    checkCursor = conn.execute(usercheck, (username,))
    singleRow = checkCursor.fetchone()
    count = int(singleRow[0])
    if count == 0:
        return jsonify({"error": f"user {username} does not exist"}), 404 # NOT FOUND
    
    query = """
        SELECT follower_username FROM followers
        WHERE followers.follows_username = ?
    """

    cursor = conn.execute(query, (username,))
    rows = cursor.fetchall()

    # Next 5 lines written with help of ChatGPT prompt: 
    # i want to create a list of dictionaries, where the dictionaries
    # are enumerations of the values of the sqlite3 rows. 
    # like 1, friendname
    followers = [
        {"follower_"+str(index + 1): row[0]}
        for index, row in enumerate(rows)
    ]
    result = followers

    conn.close()

    return jsonify(result)


if __name__ == '__main__':
    app.run(host="0.0.0.0", debug=True, port=5000)