from flask import Flask, request, jsonify
from flask_cors import CORS
from book_api import fetch_books_from_api, parse_books
import sqlite3
from flask_jwt_extended import JWTManager
from flask_jwt_extended import jwt_required, get_jwt_identity
from auth import auth, bcrypt
import os

DATABASE = "./social-books.db" # This is the .db file generated by Yoon and Connor

app = Flask(__name__)
CORS(app)  # Allow frontend to communicate with backend

bcrypt.init_app(app)  # Initialize bcrypt for password hashing

# Initialize JWT here
app.config["JWT_SECRET_KEY"] = os.getenv("JWT_SECRET_KEY", "fallback-secret-key")  # Use env variable
jwt = JWTManager(app)

# Register the authentication blueprint
app.register_blueprint(auth, url_prefix="/auth")

@app.route('/parse', methods=['POST'])
def parse_book():
    try:
        data = request.json  # Receive JSON from frontend
        book_ISBN = list(data.keys())[0]
        book_title = data[book_ISBN]["title"]
        book_author = data[book_ISBN]["author"]
        
        return jsonify({
            "ISBN": book_ISBN,
            "title": book_title,
            "author": book_author
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 400

# Author Nithin -- reference for clarification.
@app.route('/search', methods=['GET'])
def search_books():
    """
    Flask route to handle book search requests.
    
    Returns:
        Response: JSON response containing search results or an error message.
    """
    query = request.args.get('q')
    title = request.args.get('title')
    author = request.args.get('author')
    subject = request.args.get('subject')
    limit = request.args.get('limit')

    if not (query or title or author or subject):
        return jsonify({'error': 'Missing search parameter'}), 400

    # Use the fetch_books_from_api function to get the search results
    data = fetch_books_from_api(query=query, title=title, author=author, subject=subject, limit=limit)
    parsed_data = parse_books(data)
    return jsonify(parsed_data)

# @app.route('/api/data') <-- re-enable this line if things break, shouldn't need it
def db_connect():
    """ Opens a connection to the database. Hosted at 127.0.0.1 IP (localhost) """
    try:
        # Connect to the sqlite database. Modify the path at the top.
        conn = sqlite3.connect(DATABASE)
        print(f"Connection to database {DATABASE} successful.")
    except sqlite3.Error as error:
        print(f"ERROR CONNECTING {DATABASE}: errcode {error}")
    
    conn.row_factory = sqlite3.Row

    return conn

@app.route("/users/get/<string:username>", methods=["GET"])
def return_user_data(username):
    """ Returns the username as a json object. 
    Not sure of the format here, might need more work. """
    conn = db_connect()
    query = """
        SELECT * FROM reader_profiles
        WHERE reader_profiles.username = ?
    """
    # executes this query, fetches one user
    user = conn.execute(query, (username,)).fetchone()
    conn.close()

    # Return the user info as a json dictionary, should return whole tuple info
    if user:
        return jsonify(dict(user))
    else:
        return jsonify({"error": f"user {username} not found"}), 404 #NOT FOUND
 
    
@app.route("/users/add/<string:username>", methods=["POST"])
def add_user(username):
    """ Adds a user to the database """

    if not username:
        return jsonify({"error": "no username given"}), 400 #BAD REQUEST
    
    conn = db_connect()
    cursor = conn.cursor()

    # Tries to insert, if a user_id already exists sqlite3 should throw an integrity error
    # Later on we want to change this from an error to some sort of front-end behavior
    # That's for further on this week
    try:
        query = "INSERT INTO reader_profiles (username) VALUES (?)"
        cursor.execute(query, (username,))
        conn.commit()
    except sqlite3.IntegrityError:
        conn.close()
        return jsonify({"error": f"user {username} already exists"}), 409 #CONFLICT
    
    conn.close()

    return jsonify({"message": f"user {username} added successfully"}), 201 #CREATED


@app.route("/users/delete/<string:username>", methods=["DELETE"])
def delete_user(username):
    """ Removes a user from the database """
    conn = db_connect()
    cursor = conn.cursor()


    if not username:
        return jsonify({"error": "no username given for deletion"}), 400 #BAD_REQUEST
    
    query = "SELECT username FROM reader_profiles WHERE username = ?"
    cursor.execute(query, (username,))
    user = cursor.fetchone()

    if not user:
        conn.close()
        return jsonify({"error": "user not found for deletion"}), 404 #NOT FOUND

    deletion_query = "DELETE FROM reader_profiles WHERE username = ?"
    cursor.execute(deletion_query, (username,))
    conn.commit()
    conn.close()

    return jsonify({"message": f"user {username} deleted successfully"}), 200 #OK


# NOTE: doesn't look like review IDs are being generated. don't see them being inserted
@app.route("/users/reviews/add", methods=["POST"])
@jwt_required()
def add_review():
    """ Adds a review. Content of the review needs to be in the POST query.
     So far this only updates the reviews table. Maybe update other tables? Probably not. """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM reader_profiles WHERE username = ?" # replaced profile_id with uesrname
    reviewer = cursor.execute(find_user_query, (current_user,)).fetchone()

    if not reviewer:
        conn.close()
        return jsonify({"error":f"user {current_user} not found, not updating reviews"}), 400 #BAD REQUEST
    
    r_metadata = request.json
    olid = r_metadata.get("olid") #NOTE: Connor changed to olid (previously book_id)
    rating = r_metadata.get("star_rating")
    text = r_metadata.get("review_text")

    if not olid or not rating or not text:
        conn.close()
        return jsonify({"error": "olid, rating, or text is bad"}), 400 #BAD REQUEST
    
    if not (1 <= rating <= 5):
        conn.close()
        return jsonify({"error": "rating is out of 1-5 range"}), 412 #PRECONDITION FAILED
    
    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    try:
        query = "INSERT INTO reviews (username, olid, star_rating, review_text) VALUES (?, ?, ?, ?)"
        cursor.execute(query, (current_user, olid, rating, text))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    return jsonify({"message": "Review added successfully", "user_id" : current_user}), 201 #CREATED


@app.route("/users/<string:review_id>/reviews/delete", methods=["DELETE"])
def remove_review(review_id):
    """ This removes a review with a specific ID. """
    conn = db_connect()
    cursor = conn.cursor()

    find_review_query = "SELECT review_id FROM reviews WHERE review_id = ?"
    cursor.execute(find_review_query, (review_id))
    review = cursor.fetchone()

    if not review:
        conn.close()
        return jsonify({"error":f"review {review_id} not found, not updating reviews"}), 400 #BAD REQUEST
    
    deletion_query = "DELETE FROM reviews WHERE review_id = ?"
    cursor.execute(deletion_query, (review_id,))
    conn.commit()
    conn.close()

    return jsonify({"message": f"user {review_id} deleted successfully"}), 200 #OK


# NOTE: Connor addition
# NOTE: Returning "all" reviews probably isn't a great idea for
#       load times, but gets the job done for now
# GET all reviews associated with a book
@app.route("/reviews/get/<string:olid>", methods=["GET"])
def return_review_data(olid):
    """ Returns the book's reviews as a JSON object. """
    conn = db_connect()
    query = """
        SELECT * FROM reviews
        WHERE reviews.olid = ?
    """
    # executes this query, fetches one user
    reviews = conn.execute(query, (olid,)).fetchone()
    conn.close()

    # Return the book review info as a json dictionary, should return whole tuple info
    if reviews:
        return jsonify(dict(reviews))
    else:
        return jsonify({"error": f"user {olid} not found"}), 404 #NOT FOUND
 

if __name__ == '__main__':
    app.run(debug=True, port=5000)