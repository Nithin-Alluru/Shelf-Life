from flask import Flask, request, jsonify
from flask_cors import CORS
from book_api import fetch_books_from_api, parse_books, get_book
import sqlite3

reviewSerial = 0 # serial number for reviews

DATABASE = "./social-books.db" # This is the .db file generated by Yoon and Connor

app = Flask(__name__)
CORS(app)  # Allow frontend to communicate with backend

@app.route("/", methods=["GET"])
def home():
	return jsonify({"message": "Flask API is running"}), 200

## is this required anywhere? I think it was used for initial setup but no longer
## called by frontend
@app.route('/parse', methods=['POST'])
def parse_book():
    try:
        data = request.json  # Receive JSON from frontend
        book_ISBN = list(data.keys())[0]
        book_title = data[book_ISBN]["title"]
        book_author = data[book_ISBN]["author"]
        
        return jsonify({
            "ISBN": book_ISBN,
            "title": book_title,
            "author": book_author
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route('/book', methods=['GET'])
def book():
    """
    Flask route to handle book get requests.
    
    Returns:
        Response: JSON response containing book details or an error message.
    """
    work_id = request.args.get('work_id')

    # Use the get_book function to get the search results
    book = get_book(work_id=work_id)
    return book

# Author Nithin -- reference for clarification.
@app.route('/search', methods=['GET'])
def search_books():
    """
    Flask route to handle book search requests.
    
    Returns:
        Response: JSON response containing search results or an error message.
    """
    query = request.args.get('q')
    title = request.args.get('title')
    author = request.args.get('author')
    subject = request.args.get('subject')
    limit = request.args.get('limit')

    if not (query or title or author or subject):
        return jsonify({'error': 'Missing search parameter'}), 400

    # Use the fetch_books_from_api function to get the search results
    books = fetch_books_from_api(query=query, title=title, author=author, subject=subject, limit=limit)
    return jsonify(books)

# @app.route('/api/data') <-- re-enable this line if things break, shouldn't need it
def db_connect():
    """ Opens a connection to the database. Hosted at 127.0.0.1 IP (localhost) """
    try:
        # Connect to the sqlite database. Modify the path at the top.
        conn = sqlite3.connect(DATABASE)
        print(f"Connection to database {DATABASE} successful.")
    except sqlite3.Error as error:
        print(f"ERROR CONNECTING {DATABASE}: errcode {error}")
    
    conn.row_factory = sqlite3.Row

    return conn

@app.route("/users/get/<string:username>", methods=["GET"])
def return_user_data(username):
    """ Returns all user info as a json object. 
    Not sure of the format here, might need more work. """
    conn = db_connect()
    query = """
        SELECT * FROM reader_profiles
        WHERE reader_profiles.username = ?
    """
    # executes this query, fetches one user
    user = conn.execute(query, (username,)).fetchone()
    conn.close()

    # Return the user info as a json dictionary, should return whole tuple info
    if user:
        return jsonify(dict(user))
    else:
        return jsonify({"error": f"user {username} not found"}), 404 #NOT FOUND
 
    
@app.route("/users/add/<string:username>", methods=["POST"])
def add_user(username):
    """ Adds a user to the database """

    if not username:
        return jsonify({"error": "no username given"}), 400 #BAD REQUEST
    
    conn = db_connect()
    cursor = conn.cursor()

    # Tries to insert, if a user_id already exists sqlite3 should throw an integrity error
    # Later on we want to change this from an error to some sort of front-end behavior
    # That's for further on this week
    try:
        query = "INSERT INTO reader_profiles (username) VALUES (?)"
        cursor.execute(query, (username,))
        conn.commit()
    except sqlite3.IntegrityError:
        conn.close()
        return jsonify({"error": f"user {username} already exists"}), 409 #CONFLICT
    
    conn.close()

    return jsonify({"message": f"user {username} added successfully"}), 201 #CREATED


@app.route("/users/delete/<string:username>", methods=["DELETE"])
def delete_user(username):
    """ Removes a user from the database """
    conn = db_connect()
    cursor = conn.cursor()


    if not username:
        return jsonify({"error": "no username given for deletion"}), 400 #BAD_REQUEST
    
    query = "SELECT username FROM reader_profiles WHERE username = ?"
    cursor.execute(query, (username,))
    user = cursor.fetchone()

    if not user:
        conn.close()
        return jsonify({"error": "user not found for deletion"}), 404 #NOT FOUND

    deletion_query = "DELETE FROM reader_profiles WHERE username = ?"
    cursor.execute(deletion_query, (username,))
    conn.commit()
    conn.close()

    return jsonify({"message": f"user {username} deleted successfully"}), 200 #OK


@app.route("/users/<string:user_id>/reviews/add", methods=["POST"])
def add_review(user_id):
    """ Adds a review. Content of the review needs to be in the POST query.
     So far this only updates the reviews table. Maybe update other tables? Probably not. """
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM reader_profiles WHERE username = ?"
    reviewer = cursor.execute(find_user_query, (user_id,))

    if not reviewer:
        conn.close()
        return jsonify({"error":f"user {user_id} not found, not updating reviews"}), 400 #BAD REQUEST
    
    r_metadata = request.json
    review_id = reviewSerial
    work_ID = r_metadata.get("work_ID")
    rating = r_metadata.get("star_rating")
    liked = r_metadata.get("liked")
    text = r_metadata.get("review_text")

    if not work_ID or not rating or not text:
        conn.close()
        return jsonify({"error": "work_ID, rating, or text is bad"}), 400 #BAD REQUEST
    
    if not (1 <= rating <= 5):
        conn.close()
        return jsonify({"error": "rating is out of 1-5 range"}), 412 #PRECONDITION FAILED
    
    try:
        query = "INSERT INTO reviews (review_id, username, work_ID, star_rating, liked, review_text) VALUES (?, ?, ?, ?, ?, ?)"
        cursor.execute(query, (review_id, user_id, work_ID, rating, text))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    reviewSerial += 1
    return jsonify({"message": "Review added successfully", "user_id" : user_id, "review_id" : review_id, "work_ID" : work_ID}), 201 #CREATED


@app.route("/users/<string:review_id>/reviews/delete", methods=["DELETE"])
def remove_review(review_id):
    """ This removes a review with a specific ID. """
    conn = db_connect()
    cursor = conn.cursor()

    find_review_query = "SELECT review_id FROM reviews WHERE review_id = ?"
    cursor.execute(find_review_query, (review_id))
    review = cursor.fetchone()

    if not review:
        conn.close()
        return jsonify({"error":f"review {review_id} not found, not updating reviews"}), 400 #BAD REQUEST
    
    deletion_query = "DELETE FROM reviews WHERE review_id = ?"
    cursor.execute(deletion_query, (review_id,))
    conn.commit()
    conn.close()

    return jsonify({"message": f"user {review_id} deleted successfully"}), 200 #OK


# GET all reviews associated with a book
@app.route("/books/<string:work_ID>/reviews", methods=["GET"])
def return_review_data(work_ID):
    # check for valid work ID
    if work_ID == '' or work_ID == "undefined":
        return jsonify({"error": f"book {work_ID} not found or invalid"}), 404 #NOT FOUND

    """ Returns the book's reviews and review score average as a JSON object. """
    conn = db_connect()
    query = """
        SELECT * FROM reviews
        WHERE reviews.work_id = ?
    """

    # NOTE: Learned how to do the following 4 lines with ChatGPT prompt: "teach me how to create 
    # a list of dictionaries, with each list corresponding to a sqlite row, and each 
    # dictionary corresponding to a sqlite column name and its value in that row"
    cursor = conn.execute(query, (work_ID,))
    rows = cursor.fetchall()
    columns = [description[0] for description in cursor.description]
    reviews = [dict(zip(columns, row)) for row in rows]

    # default return value for no reviews
    if len(reviews) == 0:
        avg = -1
    else:
        # Get average review score
        query2 = """
        SELECT ROUND(AVG(star_rating), 1) FROM reviews
        WHERE reviews.work_id = ?
        """
        cursor = conn.execute(query2, (work_ID,))
        singleRow = cursor.fetchone()
        avg = [dict(avg_rating=singleRow[0])]


    reviews_data = {
            'work_id': work_ID, 
            'avg_rating': avg, 
            'reviews_list': reviews
    }
    conn.close()

    return jsonify(reviews_data)


# GET all reviews associated with a user
@app.route("/users/<string:username>/reviews", methods=["GET"])
def return_user_review_data(username):
    """ Returns the user's reviews as a JSON object. """
    conn = db_connect()
    query = """
        SELECT * FROM reviews
        WHERE reviews.username = ?
    """
    # NOTE: Learned how to do the following 4 lines with ChatGPT prompt: "teach me how to create 
    # a list of dictionaries, with each list corresponding to a sqlite row, and each 
    # dictionary corresponding to a sqlite column name and its value in that row"
    cursor = conn.execute(query, (username,))
    rows = cursor.fetchall()
    columns = [description[0] for description in cursor.description]
    reviews = [dict(zip(columns, row)) for row in rows]

    conn.close()

    # Return the book review info as a json dictionary, should return whole tuple info
    if reviews:
        return jsonify((reviews))
    else:
        return jsonify({"error": f"user {username} not found"}), 404 #NOT FOUND
 


# SQL for review update PUT
# 
# # newText should be an input to this function, as should review_id
#
# """
# UPDATE reviews
# SET reviews.review_text = '{newText}'
# WHERE reviews.review_id = ?
# """


if __name__ == '__main__':
    app.run(debug=True, port=5000)