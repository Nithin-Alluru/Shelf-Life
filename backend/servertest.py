import unittest
import os
import datetime
import json
from server import app  # Assuming 'app' is the Flask app instance in server.py
from flask_jwt_extended import JWTManager
from flask_jwt_extended import jwt_required, get_jwt_identity
from auth import auth, bcrypt
import time
from server import DATABASE, db_connect
import sqlite3

# Initialize JWT here
app.config["JWT_SECRET_KEY"] = os.getenv("JWT_SECRET_KEY", "fallback-secret-key")  # Use env variable
app.config["TESTING"] = True

## NOTE: These three lines were generated by ChatGPT: How would I initialize a JWT token manager for JWT unit tests?
jwt = JWTManager(app)
bcrypt.init_app(app)

# ChatGPT suggested this if statement when shown this error:
# ValueError: The name 'auth' is already registered for this blueprint. Use 'name=' to provide a unique name.
if "auth" not in app.blueprints:
    app.register_blueprint(auth, url_prefix="/auth")

# This intial unit test generated by ChatGPT prompt: Tech me how to test return_review_data in a flask context
# NOTE: You can run this with python3 -m unittest servertest.py
# Ask Connor for any clarification
class ReviewTestCase(unittest.TestCase):
    def setUp(self):
        self.app = app.test_client()
        self.test_user = {
            "username": "test",
            "password": "12345",
            "firstName": "testfirst",
            "lastName": "testlast"
        }

        
        # May need headers? Notify Yoon if required.
        # Register user
        self.app.post("/auth/register", json=self.test_user)

        # Login user to get token
        login_response = self.app.post("/auth/login", json=self.test_user)
        self.assertEqual(login_response.status_code, 200)
        login_data = login_response.get_json()
        self.token = login_data["access_token"]  # Or whatever your login route returns

        # Set auth header for future use
        self.auth_header = {
            "Authorization": f"Bearer {self.token}"
        }

        # print(f"T O K E N : {self.token}")

    #### Test USERS ####
    def test_return_user_data(self):
        #### Test Successful User Data Retrieval ####
        # Simulate a GET request with the auth header
        print("Test for Successful getting user data")
        response = self.app.get("/user", headers=self.auth_header)
        # assert successful response
        self.assertEqual(response.status_code, 200)
        # Parse the JSON response
        data = response.get_json()
        # Assert returned data contains expected fields
        self.assertTrue("username" in data)
        self.assertTrue("first_name" in data)
        self.assertTrue("last_name" in data)
        self.assertTrue("goal" in data)
        # Assert that the fields matches the test user
        self.assertEqual(data["username"], self.test_user["username"])
        self.assertEqual(data["first_name"], self.test_user["firstName"])
        self.assertEqual(data["last_name"], self.test_user["lastName"])
        self.assertEqual(data["goal"], -1)
        #### Test Unsuccessful User Data Retrieval ####
        # Simulate a GET request without the auth header
        response = self.app.get("/user")
        # Assert that the response is unauthorized (HTTP 401)
        self.assertEqual(response.status_code, 401)
        # Optionally, check if the returned JSON is correct
        data = response.get_json()
        self.assertTrue("msg" in data)
        self.assertEqual(data["msg"], "Missing Authorization Header")

    def test_add_user(self):
        pass

    def test_set_and_get_goal(self):
        # Test successful set goal
        new_goal = 10
        response = self.app.put("/goals", headers=self.auth_header, json=new_goal)
        self.assertEqual(response.status_code, 201)
        data = response.get_json()
        self.assertTrue("message" in data)
        self.assertEqual(data["message"], "Successfully updated reading goal")
        self.assertEqual(data["goal"], new_goal)
        # Test get goal
        username = self.test_user["username"]
        response = self.app.get(f"/{username}/goals", headers=self.auth_header)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertEqual(data, new_goal)
        # Test missing authorization header for set goal
        response = self.app.put("/goals", headers={}, json=new_goal)
        self.assertEqual(response.status_code, 401)
        data = response.get_json()
        self.assertTrue("msg" in data)
        self.assertEqual(data["msg"], "Missing Authorization Header")
        # Test invalid goal
        invalid_goal = -5
        response = self.app.put("/goals", headers=self.auth_header, json=invalid_goal)
        self.assertEqual(response.status_code, 412)
        data = response.get_json()
        self.assertTrue("error" in data)
        self.assertEqual(data["error"], "Reading goal must be >= 0")
        # Reset user conditions by re-running setup
        self.setUp()

        
    def test_get_token(self):
        print("Testing user authentication")
        response = self.app.post("/auth/login", json=self.test_user)
        self.assertEqual(response.status_code, 200)
        data = json.loads(response.data)
        self.assertIsNotNone(data)
        print(f"Returned token {data}")
        print("----------------------------------\n")
        

    # COMPREHENSIVE SHELVES TEST
    # Test get shelf (nonexistent)
    # Test create shelf (x2)
    # Test get shelf (empty)
    # Test get user's shelves
    # Test shelve two books
    # Test get shelf
    # Test unshelve books
    # Test get empty shelf
    # Test delete shelves
    # Test get shelf (nonexistent)
    # Test get user's shelves
    def test_shelves(self):
        print("Test shelf functionality")

        # PRE TEST CLEANUP: 
        self.app.delete('/shelf/TEST_SHELF', headers=self.auth_header)
        self.app.delete('/shelf/TEST_SHELF_2', headers=self.auth_header)

        # get nothing
        response = self.app.get('/shelf/test/TEST_SHELF', headers=self.auth_header)
        print(response.get_json())
        self.assertEqual(response.status_code, 400)

        # add shelves
        response = self.app.post('/shelf', headers=self.auth_header, json={"shelfName": "TEST_SHELF"})
        self.assertEqual(response.status_code, 201)
        response = self.app.post('/shelf', headers=self.auth_header, json={"shelfName": "TEST_SHELF_2"})
        self.assertEqual(response.status_code, 201)
        response = self.app.post('/shelf', headers=self.auth_header, json={"shelfName": "TEST_SHELF_2"})
        self.assertEqual(response.status_code, 400)


        # get empty
        response = self.app.get('/shelf/test/TEST_SHELF', headers=self.auth_header)
        data_shelf = response.get_json()
        print("get empty: " + str(data_shelf))
        self.assertTrue(len(data_shelf) == 1)

        # get user's shelves
        response = self.app.get('/shelf/test', headers=self.auth_header)
        data_shelves = response.get_json()
        print("2 shelves: " + str(len(data_shelves)) + str(data_shelves)) # eyeball it
        self.assertTrue(len(data_shelves) == 2) # 2 shelves

        # test shelve books
        response = self.app.post('/shelf/TEST_SHELF', headers=self.auth_header, json={"work_id": "777"}) # test work id is 777
        self.assertEqual(response.status_code, 201)
        response = self.app.post('/shelf/TEST_SHELF', headers=self.auth_header, json={"work_id": "999"}) # test work id is 777
        self.assertEqual(response.status_code, 201)

        # test get shelf
        response = self.app.get('/shelf/test/TEST_SHELF', headers=self.auth_header)
        full_shelf = response.get_json()
        print("full shelf: " + str(full_shelf))
        self.assertTrue(str(full_shelf) == "[{'books': [{'work_id': '777'}, {'work_id': '999'}]}]")

        # unshelve book 777
        response = self.app.delete('/shelf/TEST_SHELF/777', headers=self.auth_header)
        self.assertEqual(response.status_code, 200) # deleted - supposedly

        response = self.app.get('/shelf/test/TEST_SHELF', headers=self.auth_header)
        modified_shelf = response.get_json()
        print("modified shelf: " + str(modified_shelf))
        self.assertTrue(str(modified_shelf) == "[{'books': [{'work_id': '999'}]}]")

        # unshelve 999
        response = self.app.delete('/shelf/TEST_SHELF/999', headers=self.auth_header)
        self.assertEqual(response.status_code, 200) # deleted - supposedly

        # get empty shelf
        response = self.app.get('/shelf/test/TEST_SHELF', headers=self.auth_header)
        data_shelf = response.get_json()
        print("empty shelf: " + str(data_shelf) + str(len(data_shelf)))
        self.assertTrue(len(data_shelf) == 1) # empty length is 1

        # delete both shelves
        response = self.app.delete('/shelf/TEST_SHELF', headers=self.auth_header)
        self.assertEqual(response.status_code, 200) # deleted - supposedly
        response = self.app.delete('/shelf/TEST_SHELF_2', headers=self.auth_header)
        self.assertEqual(response.status_code, 200) # deleted - supposedly

        # get empty shelves
        response = self.app.get('/shelf/test/TEST_SHELF', headers=self.auth_header)
        self.assertEqual(response.status_code, 400)
        response = self.app.get('/shelf/test/TEST_SHELF_2', headers=self.auth_header)
        self.assertEqual(response.status_code, 400)

        # get user's shelves
        response = self.app.get('/shelf/test', headers=self.auth_header)
        data_shelves = response.get_json()

        print("all user shelves deleted. length: " + str(len(data_shelves))) # eyeball it
        self.assertTrue(len(data_shelves) == 0) # all shelves deleted
        print("PASS SHELVES")
        print("----------------------------------\n")


    def test_delete_user(self):
        print("test deleting user")
        # Test successful user deletion
        response = self.app.delete("/users/delete", headers=self.auth_header)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertTrue("message" in data)
        self.assertEqual(data["message"], f"user {self.test_user['username']} deleted successfully from users table")
        # Test deletion with missing authorization header
        response = self.app.delete("/users/delete", headers={})
        self.assertEqual(response.status_code, 401)
        data = response.get_json()
        self.assertTrue("msg" in data)
        self.assertEqual(data["msg"], "Missing Authorization Header")
        # Test deletion of a non-existent user
        response = self.app.delete("/users/delete", headers=self.auth_header)
        self.assertEqual(response.status_code, 404)
        data = response.get_json()
        self.assertTrue("error" in data)
        self.assertEqual(data["error"], "user not found for deletion from user table")
        # Reset user conditions by re-running setup
        self.setUp()
        
    def test_add_review(self):
        
        # FORCED CLEANUP
        conn = db_connect()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM reviews WHERE work_id == 'TESTWORK'")
        conn.commit()
        conn.close()
        
        print("test adding review")
        # Test successful review addition
        review_data = {
            "work_id": "TESTWORK",
            "star_rating": 5,
            "liked": True,
            "review_text": "This is a great book!"
        }
        response = self.app.post("/reviews", headers=self.auth_header, json=review_data)
        self.assertEqual(response.status_code, 201)
        data = response.get_json()
        self.assertTrue("message" in data)
        self.assertEqual(data["message"], "Review added successfully")
        self.assertEqual(data["work_ID"], review_data["work_id"])
        # Test profanity in review text
        profane_review_data = {
            "work_id": "TESTWORK",
            "star_rating": 4,
            "liked": False,
            "review_text": "fuck this book"
        }
        response = self.app.post("/reviews", headers=self.auth_header, json=profane_review_data)
        self.assertEqual(response.status_code, 412)
        data = response.get_json()
        self.assertTrue("error" in data)
        self.assertTrue("Profanity detected" in data["error"])
        
    def test_update_review(self):
        print("Test updating a review")

        # Add a review to update
        review_data = {
            "work_id": "TESTWORK",
            "star_rating": 5,
            "liked": True,
            "review_text": "This is a great book!"
        }
        add_response = self.app.post("/reviews", headers=self.auth_header, json=review_data)
        self.assertEqual(add_response.status_code, 201)
        added_review = add_response.get_json()
        review_id = added_review.get("review_id")

        # Test successful review update
        update_data = {
            "work_id": "TESTWORK",
            "star_rating": 4,
            "liked": False,
            "review_text": "Updated review text."
        }
        response = self.app.put(f"/reviews/{review_id}", headers=self.auth_header, json=update_data)
        self.assertEqual(response.status_code, 201)
        data = response.get_json()
        self.assertTrue("message" in data)
        self.assertEqual(data["message"], "Review edited successfully")
        print("----------------------------------\n")
        
    def test_return_review_data(self):
        print("Test returning review data for a book")

        # Add a review to fetch
        review_data = {
            "work_id": "TESTWORK",
            "star_rating": 5,
            "liked": True,
            "review_text": "This is a great book!"
        }
        self.app.post("/reviews", headers=self.auth_header, json=review_data)

        # Test fetching review data for the book
        response = self.app.get("/books/TESTWORK/reviews", headers=self.auth_header)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertTrue("reviews_list" in data)
        self.assertTrue(len(data["reviews_list"]) > 0)
        print("----------------------------------\n")

    def test_get_user_reviews(self):
        print("Test getting user reviews")

        # Add a review to fetch
        review_data = {
            "work_id": "TESTWORK",
            "star_rating": 5,
            "liked": True,
            "review_text": "This is a great book!"
        }
        self.app.post("/reviews", headers=self.auth_header, json=review_data)

        # Test fetching user reviews
        response = self.app.get("/user/reviews", headers=self.auth_header)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertTrue(len(data) > 0)

    def test_remove_review(self):
        print("Test removing reviews")
        
        # Add a review to remove
        review_data = {
            "work_id": "TESTWORK",
            "star_rating": 5,
            "liked": True,
            "review_text": "This is a great book!"
        }
        add_response = self.app.post("/reviews", headers=self.auth_header, json=review_data)
        self.assertEqual(add_response.status_code, 201)
        added_review = add_response.get_json()
        print("response: " + str(added_review))
        review_id = added_review.get("review_id")
        print("added review!!! " + str(review_id))
        # Test successful review removal
        response = self.app.delete(f"/reviews/{review_id}", headers=self.auth_header)
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertTrue("message" in data)
        self.assertEqual(data["message"], f"review {review_id} deleted successfully")
        
        # FORCED CLEANUP
        conn = db_connect()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM reviews WHERE work_id == 'TESTWORK'")
        conn.commit()
        conn.close()

# Contest testing
    def test_contests(self):
        conn = db_connect()
        cursor = conn.cursor()
        
        try:
            # Cleanup *before* inserting, in case of prior leftover data
            cursor.execute("DELETE FROM contest_participants WHERE contest_name = ?", ("test_contest",))
            cursor.execute("DELETE FROM contest_books WHERE contest_name = ?", ("test_contest",))
            cursor.execute("DELETE FROM contests WHERE contest_name = ?", ("test_contest",))
            conn.commit()
            
            # Testing contest creation
            payload = {
            "contest_name": "test_contest",
            "work_ids": ["OL731737W", "OL262384W", "OL45804W"],  # Example work IDs
            "end_date": "2050-01-01"
            }
            
            response = self.app.post("/contest/create", json=payload, headers=self.auth_header)

            # API tests
            response = self.app.get('/contest/test_contest/fetch', headers=self.auth_header)
            empty_works_read = response.get_json()
            print("Test")
            self.assertEqual(len(empty_works_read["readbooks"]), 0)

            response = self.app.post("/contest/mark/test_contest/OL731737W", headers=self.auth_header)
            self.assertEqual(response.status_code, 200)

            # Get read books for current user
            response = self.app.get('/contest/test_contest/fetch', headers=self.auth_header)
            works_read = response.get_json()
            self.assertEqual(len(works_read["readbooks"]), 1)
            
            # Get deadline for contest
            response = self.app.get('/contest/test_contest/deadline')
            deadline = response.get_json()
            self.assertEqual(deadline["complete"], "True")
            
            # Get contest information
            response = self.app.get("/contest/info")
            book_list = response.get_json()['contest_list']
            
            test_contest = book_list[0]
            book_count = test_contest['book_count']
            end_date = test_contest['end_date']
            organizer = test_contest['organizer']
            
            self.assertEqual(book_count, 3)
            self.assertEqual(end_date, '2050-01-01')
            self.assertEqual(organizer, "test")
            
            # Add participant / get participant
            cursor.execute("DELETE FROM contest_participants WHERE contest_name = ?", ("test_contest",))
            conn.commit()
            
            response = self.app.post('/contest/test_contest/add_participant', headers=self.auth_header)
            self.assertEqual(response.status_code, 201)
                        
            json_obj = self.app.get("/contest/test_contest/participants").get_json()
            print("json_ob participants: " + str(type(json_obj)) + "------" + str(json_obj))
            participant_list = json_obj
            self.assertTrue(len(participant_list) == 1)
            
            json_obj = self.app.get("/contest/test_contest/books").get_json()
            print("json_ob books: " + str(json_obj))
            book_list = json_obj
            self.assertTrue(len(book_list) == 3)

            print("-----PASS CONTESTS-----")

        finally:
            # Cleanup after test
            cursor.execute("DELETE FROM contest_participants WHERE contest_name = ?", ("test_contest",))
            cursor.execute("DELETE FROM contest_books WHERE contest_name = ?", ("test_contest",))
            cursor.execute("DELETE FROM contests WHERE contest_name = ?", ("test_contest",))
            cursor.execute("DELETE FROM contest_books_read WHERE contest_name = ?", ("test_contest",))
            conn.commit()
            conn.close()
            
    # ChatGPT used to generate this test. Validated and edited by Connor.abs
    # "Generate a test for followers in the style of our shelves test"
    def test_followers(self):
        print("Test follower functionality")

        # Set up a second test user to follow
        test_user_2 = {
            "username": "testuser2",
            "password": "password",
            "firstName": "Second",
            "lastName": "User"
        }


        # Attempt to unfollow testuser2 from test user (just in case it already exists)
        self.app.delete('/unfollow/testuser2', headers=self.auth_header)

        # Try to delete testuser2 account (if a delete-user endpoint exists)
        # You might wrap this in a try if it's not implemented yet
        self.app.post("/auth/login", json={
            "username": "testuser2",
            "password": "password"
        })




        # Register and log in second user
        self.app.post("/auth/register", json=test_user_2)
        login_response = self.app.post("/auth/login", json=test_user_2)
        self.assertEqual(login_response.status_code, 200)
        user2_token = login_response.get_json()["access_token"]
        user2_auth_header = {
            "Authorization": f"Bearer {user2_token}"
        }

        # Ensure user2 is initially not followed by user1
        response = self.app.get('/testuser2/followers')
        self.assertEqual(response.status_code, 200)
        followers = response.get_json()
        print("Initial followers of testuser2:", followers)
        self.assertFalse(any(f['username'] == self.test_user["username"] for f in followers))

        # Ensure user1 is not following anyone
        response = self.app.get('/test/following')
        self.assertEqual(response.status_code, 200)
        following = response.get_json()
        print("Initial following list for test:", following)
        self.assertFalse(any(f['username'] == "testuser2" for f in following))

        # User1 follows user2
        response = self.app.post('/follow', headers=self.auth_header, json={"username": "testuser2"})
        self.assertEqual(response.status_code, 201)
        print("Follow response:", response.get_json())

        # User1 tries to follow again (should fail)
        response = self.app.post('/follow', headers=self.auth_header, json={"username": "testuser2"})
        self.assertEqual(response.status_code, 500) # 500 because it violates primary key

        # Check user2's followers again (should include "test")
        response = self.app.get('/testuser2/followers')
        self.assertEqual(response.status_code, 200)
        followers = response.get_json()
        print("Updated followers of testuser2:", followers)
        self.assertTrue(any(f['username'] == "test" for f in followers))

        # Check user1's following list
        response = self.app.get('/test/following')
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertTrue(isinstance(data, list))
        self.assertTrue(len(data) <= 5)
        
        following = response.get_json()
        print("Updated following list for test:", following)
        self.assertTrue(any(f['username'] == "testuser2" for f in following))

        # Attempt to unfollow testuser2 from test user (just in case it already exists)
        self.app.delete('/unfollow/testuser2', headers=self.auth_header)

        # Try to delete testuser2 account (if a delete-user endpoint exists)
        # You might wrap this in a try if it's not implemented yet
        self.app.post("/auth/login", json={
            "username": "testuser2",
            "password": "password"
        })

        print("PASS FOLLOWERS")
        print("----------------------------------\n")


    # def test_book_search(self):
    #     # Test with general query parameter
    #     response = self.app.get('/search?q=harry+potter&limit=5')
    #     self.assertEqual(response.status_code, 200)
    #     data = response.get_json()
    #     self.assertTrue(isinstance(data, list))
    #     self.assertTrue(len(data) > 0)
        
    #     # Validate fields in first result
    #     first_book = data[0]
    #     self.assertTrue('title' in first_book)
    #     self.assertTrue('author' in first_book)
    #     self.assertTrue('work_id' in first_book)
    #     self.assertTrue('description' in first_book)
    #     self.assertTrue('img_S' in first_book)
    #     self.assertTrue('img_M' in first_book)
    #     self.assertTrue('img_L' in first_book)
        
    #     # Test with title parameter
    #     response = self.app.get('/search?title=Lord+of+the+Rings&limit=5')
    #     self.assertEqual(response.status_code, 200)
    #     data = response.get_json()
    #     self.assertTrue(isinstance(data, list))
    #     self.assertTrue(len(data) > 0)
        
    #     # Test with author parameter
    #     response = self.app.get('/search?author=J.K.+Rowling&limit=5')
    #     self.assertEqual(response.status_code, 200)
    #     data = response.get_json()
    #     self.assertTrue(isinstance(data, list))
        
    #     # Test with limit parameter
    #     response = self.app.get('/search?q=fantasy&limit=5')
    #     self.assertEqual(response.status_code, 200)
    #     data = response.get_json()
    #     self.assertTrue(isinstance(data, list))
    #     self.assertTrue(len(data) <= 5)
        
    #     # Test invalid/missing parameters
    #     response = self.app.get('/search')
    #     self.assertEqual(response.status_code, 400)
    #     data = response.get_json()
    #     self.assertTrue('error' in data)
    #     self.assertEqual(data['error'], 'Missing search parameter')
        
    # def test_book(self):        
    #     # Test with valid work ID
    #     work_id = "OL45804W"  # A known work ID
    #     response = self.app.get(f'/book/{work_id}')
    #     self.assertEqual(response.status_code, 200)
    #     data = response.get_json()
    #     # check for accurate title field
    #     self.assertTrue('title' in data)
    #     self.assertEqual(data['title'], 'Fantastic Mr Fox')  # Example title
    #     # Check of accurate author field
    #     self.assertTrue('author' in data)
    #     self.assertEqual(data['author'], 'Roald Dahl')  # Example title
    #     # Check of work_id field
    #     self.assertTrue('work_id' in data)
    #     self.assertEqual(data['work_id'], work_id)
    #     # Check of description field
    #     self.assertTrue('description' in data)
    #     self.assertTrue(len(data['description']) > 0)
    #     # Check for image url fields
    #     self.assertTrue('img_L' in data)
    #     self.assertTrue('img_S' in data)
    #     self.assertTrue('img_M' in data)
        
    #     # Test with invalid work ID - API still returns 200 with available fields
    #     bad_id = "InvalidWorkID"
    #     response = self.app.get(f'/book/{bad_id}')
    #     self.assertEqual(response.status_code, 200)
    #     data = response.get_json()
    #     self.assertTrue('error' in data)
    #     self.assertEqual(data['error'], '404 Client Error: Not Found for url: https://openlibrary.org/works/InvalidWorkID.json')
        


if __name__ == '__main__':
    unittest.main()
